<html>
	<head>
		<title> Game </title>
		<script type="text/javascript" src="seedrandom.min.js"></script>
	</head>
	
	<body style="background-color:silver">
	<div>
		<!canvas id="gameCanvas" width="700" height="550"> <!/canvas>
	</div>
	<div id="canvasesdiv" style="position:relative; width:700px; height:550px">

<canvas id="gameCanvas"
style="z-index: 2;
position:absolute;
left:0px;
top:0px;
" width="700px" height="550px">
This text is displayed if your browser does not support HTML5 Canvas.
</canvas>
<canvas id="guiCanvas"
style="z-index: 3;
position:absolute;
left:0px;
top:0px;
" width="700px" height="550">
This text is displayed if your browser does not support HTML5 Canvas.
</canvas>
</div>	
	</body>
	
	<script>
	
		var canvas = document.getElementById("gameCanvas");
		var gui = document.getElementById("guiCanvas");
		var ctx = canvas.getContext("2d");
		var guiCtx= gui.getContext("2d");
		Math.seedrandom("gol spo");
		var und = undefined;
		var doNothing=function(){};
		var iSR2 = 1/Math.sqrt(2);
		
		function setUpCanvas(){ctx.translate(350,260);
		ctx.beginPath();
		ctx.arc(0, 0, 250, 0, Math.PI*2, true); 
		ctx.closePath();
		ctx.fill();
		ctx.globalCompositeOperation = "source-atop";
		//ctx.scale(0.7,0.7);
		}
		
		window.requestAnimFrame = (function(){
          return  window.requestAnimationFrame       || 
                  window.webkitRequestAnimationFrame || 
                  window.mozRequestAnimationFrame    || 
                  window.oRequestAnimationFrame      || 
                  window.msRequestAnimationFrame     || 
                  function(/* function */ callback, /* DOMElement */ element){
                    window.setTimeout(callback, 1000 / 60);
                  };
				})();	
		
		
		
		setUpCanvas();
		ctx.fillStyle = "red";
		ctx.fillRect(-5,-5,10,10);
		ctx.strokeStyle = "red";
		
		var rot = 0;
		var invPI = 1/Math.PI;
		
		var background = new Image();
		background.src="circleBackground.png";
		
		var turret = new Image();
		turret.src="turret.png";


		var physics = [];
		
		function CollisionCircle(x,y,r,h,f){
			this.x = x;
			this.y = y;
			this.r = r;
			this.h = h; // Host (the object who has the circle)
			this.f = f; // Function
			this.dead = false;
			physics.push(this);
		}
		
		function circleCircle(a,b){
			return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)<(a.r+b.r)*(a.r+b.r);
		}
		
		
		physics.check = function(){
			for(var i=0;i<this.length;i++){
				if(this[i].dead){this.splice(i,1);i--;}
			}
			for (var i=0; i<this.length;i++){
				for (var j=i+1; j<this.length;j++){
					if (circleCircle(this[i],this[j])){
						(this[i].f)&&(this[i].f.call(this[i].h,this[j].h));
						(this[j].f)&&(this[j].f.call(this[j].h,this[i].h));
					}
				}
			}

		}
		physics.draw = function(){
			ctx.save();
			ctx.strokeStyle="blue";
			ctx.beginPath();
			for(var i=0;i<this.length;i++){
				ctx.arc(this[i].x, this[i].y, this[i].r, 0, Math.PI*2, true); 
			
			}
			ctx.closePath();
			ctx.stroke();
			ctx.restore();
		}
		
		function Player(){
			this.rot=0;        // for player's Rotation
			this.s=0.007;    // for player's rotation Speed
			this.c="orange"; // for player's Color
			this.bc="green"; // for Beam Color
			this.player=true;
			this.shooting=false;
			this.energy= 100;
			this.reload = 0;
			this.collisionFunction = function(){}
			this.physics = new CollisionCircle(0,0,16,this,this.collisionFunction);
		}
		
		Player.prototype.update=function(){
			this.rot%=2;
			this.rot+=this.s;
			((!this.reload)&&this.shooting&&(this.energy>10))?this.shoot():(this.reload)?(this.reload--):(this.energy<100&&(this.energy+=0.5));
		}
		
		Player.prototype.draw=function(){
			ctx.save();
			ctx.drawImage(turret,-16,-16);
			ctx.strokeStyle = this.bc;
			ctx.beginPath();
			ctx.moveTo(0,0);
			ctx.lineTo(Math.sin(Math.PI*this.rot)*250,Math.cos(Math.PI*this.rot)*250);
			ctx.lineWidth = 2
			ctx.stroke();
			
			ctx.restore();
		}
		
		Player.prototype.changeDir=function(){
			this.s*=-1;
		}
		Player.prototype.shoot = function(){
			new PlayerBullet(Math.sin(Math.PI*this.rot)*4,Math.cos(Math.PI*this.rot)*4,Math.sin(Math.PI*this.rot)*3,Math.cos(Math.PI*this.rot)*3,30)
			this.energy-=10;
			this.reload=5;
			console.log(this.energy);
		}
		
		function StraightWalker(x,y,r,s,rs,rr,rd){
			this.x = x;
			this.y = y;
			this.rot=(r!=und)?r:0;
			this.s=(s!=und)?s:1;     // Speed
			this.rs =(rs!=und)?rs:0.05; // Rotation Speed 
			this.rr =(rr!=und)?rr:0.01; // Rotation Randomness // + or -
			this.rd =(rd!=und)?rd:0; // Rotation Deviation // makes it go in spirals
			this.enemy = true;
			this.makeForm();
			this.makePhysics();
			this.color="red";
			enemies.push(this);
		}
		StraightWalker.prototype.makeForm=function(){this.w=10,this.h=15};
		StraightWalker.prototype.collisionFunction=function(h){if(h.playerWeapon){this.die();}};
		
		StraightWalker.prototype.die=function(){this.dead=true;this.killPhysics()}
		
		StraightWalker.prototype.makePhysics=function(){
		this.physics = new CollisionCircle(this.x,this.y,Math.max(this.w,this.h)*iSR2,this,this.collisionFunction);
		};
		
		StraightWalker.prototype.killPhysics=function(){this.physics.dead=true;};
		
			
		
		StraightWalker.prototype.update=function(){
			var dr = ((Math.atan2(this.x,this.y)/Math.PI)-1)%2+this.rd;
			var acw = (dr-this.rot+2)%2;
			var cw = (this.rot-dr+2)%2;
			this.rot = ((acw<cw)?this.rot+Math.min(acw,this.rs):this.rot-Math.min(cw,this.rs))+this.rr-Math.random2()*this.rr*2;
			this.x+=Math.sin(Math.PI*this.rot)*this.s;
			this.y+=Math.cos(Math.PI*this.rot)*this.s;
			this.physics.x = this.x;
			this.physics.y = this.y;
		}
		StraightWalker.prototype.draw = function(){
			ctx.save();
			ctx.translate(this.x,this.y);
			ctx.rotate(Math.PI*(1-this.rot))
			ctx.fillStyle=this.color;
			ctx.fillRect(this.w*-0.5,this.h*-0.5,this.w,this.h);
			
			ctx.restore();
		}
		
		function PlayerBullet(x,y,vx,vy,s,pt){
			this.x=x;
			this.y=y;
			this.vx=vx;
			this.vy= vy;
			this.s=s;
			this.ms=s*0.5;
			this.playerWeapon=true;
			this.damage = 5;
			this.collisionFunction=(pt)?function(h){if(!(h.player||h.playerWeapon)){this.dead=true;this.physics.dead=true}}:doNothing;
			this.physics = new CollisionCircle(x,y,s*0.5,this,this.collisionFunction)
			bullets.push(this);
		}
		PlayerBullet.prototype.update=function(){
			this.x+=this.vx;
			this.y+=this.vy;
			this.physics.x=this.x;
			this.physics.y=this.y;
			if(this.x*this.x+this.y*this.y>62500+this.ms*this.ms+this.ms*500){this.dead=true;this.physics.dead=true}
		}
		PlayerBullet.prototype.draw=function(){
		ctx.save()
		ctx.fillStyle="lime"
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.s*0.5, 0, Math.PI*2, true); 
		ctx.closePath();
		ctx.fill();
		ctx.restore();
		}
		
		var player = new Player(); 
		var enemies =[];
		var bullets =[];
		for(var i=0,n=50;i<n;i++){
			new StraightWalker(Math.sin(Math.PI*i/n*2+Math.random2())*250,Math.cos(Math.PI*i/n*2+Math.random2())*250,Math.PI*i/n,Math.random2()*0.1+0.1,0.01,Math.random2()*0.2,Math.random2()*0.4-0.2); 
		 
		 }
		
		enemies.update=function(){
			for(var i=0;i<this.length;i++){
				if(this[i].dead){this.splice(i,1);i--}else{ this[i].update();}
			}
		}
		enemies.draw=function(){
			for(var i=0;i<this.length;i++){
				this[i].draw();
			}
		}
		bullets.update=enemies.update;
		
		bullets.draw=enemies.draw;
		
		function updateAll(){
			player.update();
			bullets.update();
			enemies.update();
			physics.check();
		}
		
		function drawAll() {
			ctx.save();
			ctx.fillStyle="black";
			ctx.drawImage(background,-250,-250);
			ctx.restore();
			drawGui();
			player.draw();
			enemies.draw();
			bullets.draw();
			//player.beamDraw();
			requestAnimFrame(drawAll);
		}
		function keyDown(evt){
				if (evt.keyCode == 32) {player.shooting=true;}
	if (evt.keyCode == 13) {player.changeDir();}
		}
		
		function keyUp(evt){
				if (evt.keyCode == 32) {player.shooting=false;}
	//if (evt.keyCode == 13) {player.changeDir();}
		}
		
		function drawGui(){
			guiCtx.clearRect(0,0,700,550);
			guiCtx.save()
		
			guiCtx.globalCompositeOperation = "source-over";
			guiCtx.fillStyle="rgb(0,"+(255-25*player.reload)+",0)";
			guiCtx.fillRect(40,500,50,player.energy*-4);
			guiCtx.restore()
		
		}
		
		document.addEventListener("keydown",keyDown,false)
		document.addEventListener("keyup",keyUp,false)
		setInterval(updateAll,10);
		drawAll();
		
	</script>
	
</html>
